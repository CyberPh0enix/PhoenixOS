import { useState, useEffect } from "react";
import { encodeSecret } from "./crypto";
import { supabase } from "../lib/supabase";

const EXPLOIT_CONFIG = {
  sequence: "m a t r i x",
  onionUrl: "/api/darkmarket/v1/root-override",
};

export const devExploitManager = {
  triggerDevMode: () => {
    localStorage.setItem(
      "_SYS_SEC_TOKEN",
      encodeSecret(EXPLOIT_CONFIG.sequence),
    );

    fetch(EXPLOIT_CONFIG.onionUrl, {
      method: "POST",
      headers: {
        "X-Diagnostic-Hint": "Check LocalStorage. Trace _SYS_SEC_TOKEN.",
        "X-Action": "Type decoded sequence on desktop to override.",
      },
    }).catch(() => {});
  },
};

export const useDevExploitSequence = (activeApp, onUnlock) => {
  const [keyIndex, setKeyIndex] = useState(0);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (activeApp) return;

      const storedToken = localStorage.getItem("_SYS_SEC_TOKEN");
      if (!storedToken) return;

      const char = e.key.toLowerCase();
      if (char === EXPLOIT_CONFIG.sequence[keyIndex]) {
        const nextIndex = keyIndex + 1;
        if (nextIndex === EXPLOIT_CONFIG.sequence.length) {
          localStorage.setItem(
            "_SYS_ROOT_UNLOCKED",
            encodeSecret(EXPLOIT_CONFIG.sequence),
          );
          setKeyIndex(0);
          onUnlock?.();
        } else {
          setKeyIndex(nextIndex);
        }
      } else {
        setKeyIndex(0);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [keyIndex, activeApp, onUnlock]);
};

export const heistCommand = {
  hidden: true,
  execute: async (args, { addToHistory, user }) => {
    const requiredHash = encodeSecret(EXPLOIT_CONFIG.sequence);
    if (localStorage.getItem("_SYS_ROOT_UNLOCKED") !== requiredHash) {
      addToHistory("error", `bash: ${args[0]}: command not found`);
      return;
    }

    if (!args[1] || isNaN(args[1])) {
      addToHistory("error", "Usage: heist <amount>");
      return;
    }

    const requestedAmount = parseInt(args[1]);
    const bankEmail = import.meta.env.VITE_BANK_EMAIL;

    if (!bankEmail) {
      addToHistory(
        "error",
        "SYSTEM ERR: Bank routing environment variable missing.",
      );
      return;
    }

    const { data: bankData, error: bankError } = await supabase
      .from("profiles")
      .select("id")
      .eq("email", bankEmail)
      .single();

    if (bankError || !bankData) {
      addToHistory(
        "error",
        "CONNECTION FAILED: Central Bank node is offline or missing.",
      );
      return;
    }

    const { data, error } = await supabase.rpc("siphon_from_bank", {
      attacker_id: user.id,
      requested_amount: requestedAmount,
      bank_id: bankData.id,
    });

    if (error) {
      addToHistory(
        "error",
        "TRANSACTION BLOCKED: Firewall intercepted payload.",
      );
      return;
    }

    if (data?.startsWith("SUCCESS")) {
      addToHistory(
        "success",
        `CREDITS ACQUIRED: ${data.split(":")[1]} siphoned.`,
      );
    } else {
      addToHistory("error", "RESERVE EMPTY OR CONNECTION TERMINATED.");
    }
  },
};
